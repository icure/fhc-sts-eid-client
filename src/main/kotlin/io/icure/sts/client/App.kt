/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package io.icure.sts.client

import be.fedict.commons.eid.client.BeIDCards
import be.fedict.commons.eid.client.FileType
import be.fedict.commons.eid.client.impl.BeIDDigest
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.registerKotlinModule
import org.apache.commons.logging.LogFactory
import org.springframework.messaging.converter.MappingJackson2MessageConverter
import org.springframework.messaging.simp.stomp.StompCommand
import org.springframework.messaging.simp.stomp.StompFrameHandler
import org.springframework.messaging.simp.stomp.StompHeaders
import org.springframework.messaging.simp.stomp.StompSession
import org.springframework.messaging.simp.stomp.StompSessionHandlerAdapter
import org.springframework.web.socket.client.jetty.JettyWebSocketClient
import org.springframework.web.socket.messaging.WebSocketStompClient
import java.util.*
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock

data class Message(val action: String, val keystoreId: String? = null, val name: String? = null, val digestType: String? = null, val data: String? = null)
class App {
    val log = LogFactory.getLog(this::class.java)
    fun start() {
        val lock = ReentrantLock()
        var shouldReconnect = true

        val stompClient = WebSocketStompClient(JettyWebSocketClient().apply { start() }).apply {
            messageConverter = MappingJackson2MessageConverter().apply { objectMapper = ObjectMapper().registerKotlinModule() }
        }
        val sessionHandler = object : StompSessionHandlerAdapter() {
            val card = BeIDCards().oneBeIDCard
            override fun afterConnected(session: StompSession, connectedHeaders: StompHeaders) {
                val uuid = connectedHeaders["user-name"]?.firstOrNull() ?: throw IllegalStateException("Invalid session, no user")
                val stsUserTopic = "/topic/sts/${uuid}"
                session.subscribe(stsUserTopic, object : StompFrameHandler {
                    override fun getPayloadType(headers: StompHeaders): Class<Message> {
                        return Message::class.java
                    }
                    override fun handleFrame(headers: StompHeaders, payload: Any) {
                        payload as Message
                        if (payload.action == "readFile") {
                            session.send(
                                "/app/msg", mapOf(
                                    "content" to Base64.getEncoder().encodeToString(
                                        card.readFile(
                                            when (payload.name) {
                                                "Authentication" -> FileType.AuthentificationCertificate
                                                "Signature" -> FileType.NonRepudiationCertificate
                                                "RRN" -> FileType.RRNCertificate
                                                "Root" -> FileType.RootCertificate
                                                "CA" -> FileType.CACertificate
                                                else -> throw IllegalArgumentException("Invalid file ${payload.name}")
                                            }
                                        )
                                    )
                                )
                            )
                        } else if (payload.action == "sign") {
                            session.send(
                                "/app/msg",
                                mapOf("content" to Base64.getEncoder().encodeToString(
                                    card.sign(
                                        Base64.getDecoder().decode(payload.data),
                                        BeIDDigest.valueOf(payload.digestType ?: "SHA_1"),
                                        FileType.AuthentificationCertificate,
                                        true
                                    ))
                                )
                            )
                        } else if (payload.action == "connected") {
                            println("Keystore id: ${payload.keystoreId}")
                        }
                    }
                })
                session.send("/app/sts", emptyMap<String, String>())
            }

            override fun handleException(
                session: StompSession,
                command: StompCommand?,
                headers: StompHeaders,
                payload: ByteArray,
                exception: Throwable
            ) {
                super.handleException(session, command, headers, payload, exception)
            }

            override fun handleTransportError(session: StompSession, exception: Throwable) {
                super.handleTransportError(session, exception)

                log.error("Transport error has occurred", exception)
                lock.withLock {
                    shouldReconnect = true
                }
            }
        }

        while(true) {
            lock.withLock {
                if (shouldReconnect) {
                    shouldReconnect = false
                    stompClient.connect("ws://localhost:8090/ws", sessionHandler)
                }
            }
            Thread.sleep(5000)
        }
    }
}

fun main() {
    System.setProperty(
        "sun.security.smartcardio.library",
        "/System/Library/Frameworks/PCSC.framework/Versions/Current/PCSC"
    )

    App().start()
}
